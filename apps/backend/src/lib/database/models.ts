import { Collection, Db } from 'mongodb';
import type { PluginConfig } from '@sanity-notion-llm/shared';

/*===============================================
|=           DATABASE SCHEMA DOCUMENTATION     =
===============================================

MongoDB vs SQL Database Concepts:
- MongoDB uses "collections" instead of "tables"
- MongoDB uses "documents" instead of "rows" 
- MongoDB is schema-less (no predefined structure)
- TypeScript interfaces define the "shape" of documents

Key Points:
1. The interfaces below are TypeScript types, NOT database schemas
2. MongoDB will store whatever fields you provide
3. Optional fields (?) can be missing from documents
4. _id is auto-generated by MongoDB (like SQL AUTO_INCREMENT)
5. Indexes improve query performance (like SQL indexes)

===============================================*/

/**
 * GENERATION RECORDS COLLECTION
 *
 * Purpose: Tracks content generation jobs from Notion to Sanity
 * Collection Name: "generations"
 *
 */
export interface GenerationRecord {
  _id?: string;
  configId: string;
  notionPageId: string;
  notionPageTitle: string;
  scheduledDate: Date;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  sanityDocumentId?: string;
  errorMessage?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ConfigRecord extends PluginConfig {
  _id?: string;
}

/*===============================================
|=           COLLECTION ACCESS FUNCTIONS       =
===============================================

These functions get MongoDB collections with proper TypeScript typing.
Think of them like getting a reference to a SQL table.

Usage:
  const db = await connectToDatabase();
  const configs = getConfigsCollection(db);
  const config = await configs.findOne({ studioId: "studio123" });

===============================================*/

/**
 * Get the "configs" collection with TypeScript typing
 * @param db - MongoDB database connection
 * @returns Typed collection for config records
 */
export const getConfigsCollection = (db: Db): Collection<ConfigRecord> =>
  db.collection<ConfigRecord>('configs');

export const getGenerationsCollection = (
  db: Db
): Collection<GenerationRecord> =>
  db.collection<GenerationRecord>('generations');

/*===============================================
|=           DATABASE INDEXES                  =
===============================================

Indexes improve query performance (like SQL indexes).
They create "fast lookup tables" for common queries.

Example: Without an index on studioId, MongoDB has to scan every document.
With an index, it can jump directly to the right document.

===============================================*/

/**
 * Create database indexes for optimal query performance
 *
 * This function sets up indexes (like SQL CREATE INDEX statements):
 *
 * CONFIGS COLLECTION INDEXES:
 * - studioId (unique): Ensures only one config per studio + fast lookups
 * - isActive: Fast filtering of active vs inactive configs
 *
 * GENERATIONS COLLECTION INDEXES:
 * - configId: Fast lookups of all generations for a specific config
 * - status: Fast filtering by status (pending, processing, etc.)
 * - scheduledDate: Fast date range queries (find items due for processing)
 * - createdAt: Fast sorting by creation time
 *
 * @param db - MongoDB database connection
 */
export async function createDatabaseIndexes(db: Db): Promise<void> {
  try {
    const configs = getConfigsCollection(db);
    const generations = getGenerationsCollection(db);

    // Index for configs collection
    await configs.createIndex({ studioId: 1 }, { unique: true });
    await configs.createIndex({ isActive: 1 });

    // Index for generations collection
    await generations.createIndex({ configId: 1 });
    await generations.createIndex({ status: 1 });
    await generations.createIndex({ scheduledDate: 1 });
    await generations.createIndex({ createdAt: 1 });

    console.log('[database] Indexes created successfully');
  } catch (error) {
    console.error('[database] Failed to create indexes:', error);
    throw error;
  }
}
