import { createClient, SanityClient } from '@sanity/client';

/*===============================================
|=                SanityService                 =
===============================================*/

/**
 * SANITY CMS SERVICE
 *
 * Manages document creation and management in Sanity CMS.
 * Handles draft creation, approval workflow, and document queries.
 *
 * Key Features:
 * - Draft Management: Creates draft documents for review workflow
 * - Approval System: Approve/reject drafts with metadata tracking
 * - Document Queries: Fetch drafts and published content
 * - Multi-tenant: Works with any Sanity project via credentials
 *
 * Workflow:
 * 1. Create Draft: LLM-generated content saved as draft
 * 2. Review: Editors review drafts in Sanity Studio
 * 3. Approve/Reject: Mark drafts as approved or rejected
 * 4. Publish: Approved drafts can be published (future feature)
 *
 * Document Structure:
 * - Standard Sanity fields (_type, _id, etc.)
 * - Custom metadata: _approved, _rejected flags
 * - Content fields: Generated by LLM based on schema
 *
 * Security:
 * - Uses encrypted Sanity tokens from configuration
 * - Validates all inputs before document creation
 * - No direct client access - all operations server-side
 */

export class SanityService {
  private client: SanityClient;

  constructor(
    projectId: string,
    token: string,
    dataset: string = 'production'
  ) {
    this.client = createClient({
      projectId,
      token,
      dataset,
      useCdn: false,
      apiVersion: '2023-03-01',
    });
  }

  // Create a draft document
  async createDraft(schemaType: string, document: Record<string, any>) {
    // Generate a random ID and prefix with 'drafts.' to ensure it's saved as a draft
    const draftId = `drafts.${this.generateId()}`;

    const docWithMeta = {
      ...document,
      _id: draftId,
      _type: schemaType,
      _approved: false,
      _rejected: false,
    };

    return this.client.create(docWithMeta);
  }

  // Generate a random ID for draft documents
  private generateId(): string {
    return (
      Math.random().toString(36).substring(2, 15) +
      Math.random().toString(36).substring(2, 15)
    );
  }

  // Query draft documents
  async queryDrafts(options: { type?: string }) {
    const { type } = options;
    const query = `*[_type == "${type || 'article'}" && _id in path("drafts.**")]`;
    return this.client.fetch(query);
  }

  // Fetch a document by ID (draft or published)
  async getDocument(documentId: string) {
    try {
      return await this.client.getDocument(documentId);
    } catch (error) {
      console.warn(`[sanity] Document ${documentId} not found:`, error);
      return null;
    }
  }

  // Approve a document - not funcitonal yet
  /*===============================================
  =          NOT WORKING            =
  ===============================================*/

  async approveDocument(documentId: string) {
    return this.client
      .patch(documentId)
      .set({ _approved: true, _rejected: false })
      .commit();
  }

  // Reject a draft
  async rejectDocument(documentId: string) {
    return this.client
      .patch(documentId)
      .set({ _approved: false, _rejected: true })
      .commit();
  }

  // Publish a draft (remove drafts. prefix to make it published)
  async publishDraft(documentId: string) {
    // First, get the draft document
    const draft = await this.client.getDocument(documentId);
    
    // If draft doesn't exist, check if it's already published
    if (!draft) {
      // Check if published version exists
      const publishedId = documentId.replace('drafts.', '');
      const publishedDoc = await this.client.getDocument(publishedId);
      
      if (publishedDoc) {
        // Already published, return the published document
        return publishedDoc;
      }
      
      // Neither draft nor published version exists
      throw new Error(`Draft document ${documentId} not found`);
    }

    // Create the published version by removing the drafts. prefix
    const publishedId = documentId.replace('drafts.', '');

    // Check if published version already exists
    const existingPublished = await this.client.getDocument(publishedId);
    
    if (existingPublished) {
      // Already published, delete the draft and return published version
      try {
        await this.client.delete(documentId);
      } catch (deleteError) {
        // Ignore delete errors (draft might already be deleted)
        console.warn(`[sanity] Could not delete draft ${documentId}:`, deleteError);
      }
      return existingPublished;
    }

    // Create the published document (remove _id to replace it)
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { _id, ...draftWithoutId } = draft;
    const publishedDoc = {
      ...draftWithoutId,
      _id: publishedId,
    };

    // Create or replace the published document (handles case where published version already exists)
    const result = await this.client.createOrReplace(publishedDoc);

    // Delete the draft
    try {
      await this.client.delete(documentId);
    } catch (deleteError) {
      // Ignore delete errors (draft might already be deleted)
      console.warn(`[sanity] Could not delete draft ${documentId}:`, deleteError);
    }

    return result;
  }
}

export function createSanityService(
  projectId: string,
  token: string,
  dataset?: string
): SanityService {
  return new SanityService(projectId, token, dataset);
}
